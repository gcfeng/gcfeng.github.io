<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>make 基础教程</title>
    <url>/make/</url>
    <content><![CDATA[<p>make 是一个 Linux 环境下的构建工具，主要用于管理 C 语言项目。但是实际上，make 不仅仅用来编译源代码，也可以完成一些其他功能。任何只要某个文件发生变化，就需要重新构建的项目，都可以使用 make 来管理。</p>
<a id="more"></a>
<h2 id="make-介绍">make 介绍</h2>
<p>新建项目后进入到项目目录，在命令行中执行 <code>make</code>，并不会有任何作用。make 本身只是一个命令行工具，它不知道该如何构建项目，需要明确告诉 make 以何种规则来编排项目，比如需要将文件 main.c 编译为 main.o 文件，make 需要知道如下规则： <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">    cc -c main.c</span><br></pre></td></tr></table></figure> 当使用 make 来进行构建时，实际上 make 做了以下几件事情： - 确认 main.c 文件存在 - 如果存在 main.o 文件，且 main.o 文件最后修改的时间戳要比 main.c 晚，不会重新编译 - 如果不存在 main.o 文件，或者 main.o 文件最后修改的时间戳要比 main.c 早，进行编译</p>
<p>一个工程可能有很多这样的规则，这些规则会被写到一个文件中，make 依赖这个文件来进行构建。make 默认会按照 GNUmakefile、makefile、Makefile 的名称顺序来查找该文件，推荐使用 Makefile 来命名。如果需要自定义名称，也可以通过命令行参数来指定： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -f otherName.txt</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">make --file=otherName.txt</span><br></pre></td></tr></table></figure> ## Makefile规则 Makefile 文件包含一系列规则。每条规则的格式如下： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;target&gt;: &lt;prerequisites&gt;</span><br><span class="line">[tab]   &lt;command&gt;</span><br></pre></td></tr></table></figure> target 是规则的目标，prerequisites 是前置条件，command 是要执行的命令。目标是必需的，前置条件和命令都是可选的，但是两者之中必须至少存在一个。每条规则就是描述在什么前置条件下，该如何构建目标。</p>
<h3 id="目标target">目标（target）</h3>
<p>规则的目标通常是最后需要生成的文件名，比如上述的 main.o。当然除了文件名，目标也可以是某个执行操作的名称，我们称这样的目标为“伪目标”。比如： <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.o</span><br></pre></td></tr></table></figure> clean 不是一个文件名，而是一个执行操作的名称，它是一个伪目标，它的作用是删除工作目录中所有后缀为 o 的对象文件。当然，上面的声明仅仅是概念上的区分。在工作目录中执行 <code>make clean</code>，如果工作目录中存在文件 <code>clean</code>，这条命令将不会执行。因为 make 发现 clean 文件已经存在，就不会重新进行构建了。为了避免出现这种情况，我们可以明确声明 clean 是“伪目标”，写法如下： <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.o</span><br></pre></td></tr></table></figure> 默认情况下，make 执行 Makefile 中的第一个规则，此规则的第一个目标称之为“最终目的”或者“终极目标”，有点像是 grunt 或者 gulp 中的 default。</p>
<h3 id="前置条件prerequisites">前置条件（prerequisites）</h3>
<p>前置条件通常是一组用空格分隔的文件名。它表明了两件事情：一是此规则目标依赖哪些目标文件来触发重新构建，二是重建此规则目标需要先重建哪些规则目标。比如有以下规则： <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">main: main.o util.o</span></span><br><span class="line">    cc main.o util.o -o main</span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">    cc -c main.c</span><br><span class="line"></span><br><span class="line"><span class="section">util.o: util.c util.h</span></span><br><span class="line">    cc -c util.c</span><br></pre></td></tr></table></figure> main 的前置条件是 main.o 和 util.o。在构建目标 main 前，make 会先构建目标 main.o 和 util.o。如果无需构建 main.o 和 util.o，换句话说，也就是存在文件 main.o 和 util.o，且它们的最后修改时间戳最新，如果文件 main 存在，规则 main 也无需被构建。</p>
<h3 id="命令command">命令（command）</h3>
<p>规则的命令由一些 shell 命令组成，它们被一条一条的执行。命令表明了规则具体要做哪些操作，通常是更新目标文件。每条命令必须以 [tab] 字符开始，多个命令行之间可以有空行和注释行（空行是不包括任何字符的一行），在执行规则时空行会被忽略。如果希望用其他字符来代替 [tab]，可以指定 <a href="https://www.gnu.org/software/make/manual/html_node/Special-Variables.html#Special-Variables">.RECIPEPREFIX</a>： <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 &gt; 来代替 [tab] 字符</span></span><br><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">&gt; cc -c main.c</span><br></pre></td></tr></table></figure> 需要注意的是每行命令的执行是在一个独立的 shell 进程中完成的。因此多行命令之间的执行是相互独立，不存在依赖的。当规则的命令中存在使用 cd 来改变工作目录时，其结果并不会对往后的命令产生任何影响。有以下几种方式来解决： <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法一：将命令写在一行，用分号分隔</span></span><br><span class="line"><span class="section">var-kept:</span></span><br><span class="line">    <span class="keyword">export</span> foo=bar; echo <span class="string">&quot;foo=[$$foo]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二：使用反斜杠（\）来连接</span></span><br><span class="line"><span class="section">var-kept:</span></span><br><span class="line">    <span class="keyword">export</span> foo=bar; \</span><br><span class="line">    echo <span class="string">&quot;foo=[$$foo]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法三：使用 .ONESHELL，该方式在GNU Make 3.82以上支持</span></span><br><span class="line"><span class="section">.ONESHELL:</span></span><br><span class="line"><span class="section">var-kept:</span></span><br><span class="line">    <span class="keyword">export</span> foo=bar</span><br><span class="line">    echo <span class="string">&quot;foo=[$$foo]&quot;</span></span><br></pre></td></tr></table></figure> 命令在运行结束之后，make 会检测命令执行的返回状态，如果返回成功，make 会启动下一个子 shell 来执行下一条命令。如果某条命令出错了（返回非0状态），make 就会放弃对当前规则往后命令的执行。可以在命令之前加一个减号“-”来告诉 make 忽略此命令的执行失败，比如： <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    -rm *.o</span><br></pre></td></tr></table></figure> ## Makefile 变量 Makefile 允许变量定义，变量是使用一个字符或字符串来代表一段字符串，有点类似于 C 语言的宏。Makefile 中规则的目标、前置条件和命令都可引用变量。变量的引用比较简单，引用一个变量的形式是：<code>$(VAR_NAME)</code> 或 <code>$&#123;VAR_NAME&#125;</code>。</p>
<p>在定义一个变量时，变量名不能包含 <code>:</code>、<code>#</code>、<code>=</code>、前置空白和尾空白。通常使用字母、数字和下划线来定义变量。同时，变量名是大小写敏感的。</p>
<h3 id="变量定义">变量定义</h3>
<p>Makefile 支持几种变量定义的方式，我们来一一说明。</p>
<h4 id="递归展开式变量">递归展开式变量</h4>
<p>使用等号来定义变量，格式为：<code>VAR_NAME = value</code>。这种变量在引用的地方是严格的文本替换过程，变量值的字符串会原样的出现在引用它的地方。比如下面例子： <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">a = <span class="variable">$(b)</span></span><br><span class="line">b = <span class="variable">$(c)</span></span><br><span class="line">c = c</span><br><span class="line"></span><br><span class="line"><span class="section">main:</span></span><br><span class="line">    echo <span class="variable">$(a)</span></span><br></pre></td></tr></table></figure> 执行 make 会输出 c 。整个变量的替换过程是这样的：首先 <code>$(a)</code> 被替换为 <code>$(b)</code>，接着 <code>$(b)</code> 被替换为 <code>$(c)</code>，最后 <code>$(c)</code> 被替换为 c。整个替换过程是在执行 <code>echo $(a)</code> 时完成的。这种方式定义的变量可以引用其后定义的变量，并且支持递归展开，所以也称之为递归展开变量。也正因为如此，此风格的变量定义会导致 make 陷入到无限的变量展开过程中。比如： <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">a = <span class="variable">$(b)</span></span><br><span class="line">b = <span class="variable">$(a)</span></span><br></pre></td></tr></table></figure> #### 直接展开式变量 另外一种变量定义是使用 <code>:=</code> ，格式为：<code>VAR_NAME := value</code>。这种变量的变量值是在定义变量时被展开的，所以变量被定义后就是一个实际需要的文本串，其中不再包含任何变量的引用。比如： <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">a := a</span><br><span class="line">b := <span class="variable">$(a)</span> b</span><br><span class="line">a := after</span><br></pre></td></tr></table></figure> 其等价于： <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">b := a b</span><br><span class="line">a := after</span><br></pre></td></tr></table></figure> 和递归式展开变量不同，此风格变量在定义时就完成了对所引用变量的展开，因此不能引用其后定义的变量。</p>
<h4 id="多行定义">多行定义</h4>
<p>指示符 define 可以定义一个包含多行字符串的变量，格式为： <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> VAR_NAME</span><br><span class="line">    command</span><br><span class="line">    command</span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure> ### 条件赋值 Makefile 可以使用 <code>?=</code> 来进行条件赋值，格式为 <code>VAR_NAME ?= value</code>。只有当变量在之前没有赋值的情况下才会对这个变量进行赋值。比如： <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">a ?= b</span><br></pre></td></tr></table></figure> 其含义是：如果变量 a 在之前没有定义，就给它赋值 b，否则不改变它的值。</p>
<h3 id="追加变量值">追加变量值</h3>
<p>Makefile 使用 <code>+=</code> 来追加变量值，格式为 <code>VAR_NAME += value</code>。这使得我们可以先定义一个通用变量，然后在别的地方追加值。比如： <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = a.o b.o</span><br><span class="line">objects += c.o</span><br></pre></td></tr></table></figure> 相当于： <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = a.o b.o</span><br><span class="line">objects := <span class="variable">$(objects)</span> c.o</span><br></pre></td></tr></table></figure> 执行操作之后，objects 的值为 "a.o b.o c.o"。</p>
<h3 id="override-指示符">override 指示符</h3>
<p>在执行 make 时，如果通过命令行定义了一个变量，它将替代在 Makefile 中出现的同名变量。比如： <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">a = a</span><br><span class="line"><span class="section">main:</span></span><br><span class="line">    echo <span class="variable">$(a)</span></span><br></pre></td></tr></table></figure> 执行命令 <code>make a=c</code>，终端会输出 c。如果不希望发生这种替代，只需要在变量定义前加上 override 即可。</p>
<h2 id="makefile-条件判断">Makefile 条件判断</h2>
<p>Makefile 使用 <code>ifeq</code>、<code>ifneq</code>、<code>ifdef</code>、<code>ifndef</code> 来进行条件判断，格式为： <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CONDITIONAL-DIRECTIVE</span><br><span class="line">TEXT-IF-TRUE</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">TEXT-IF-FALSE</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure> 比如以下例子： <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo = bar</span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(foo)</span>,bar)</span><br><span class="line">  foo_defined = yes</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  foo_defined = no</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="section">main:</span></span><br><span class="line">    echo <span class="variable">$(foo_defined)</span></span><br></pre></td></tr></table></figure> 执行 <code>make</code>，终端会输出 yes。这里有几个需要注意地方： - 条件判断<code>($(foo),bar)</code>中的逗号两边没有空格 - 条件体中的开头不能是 tab 字符，否则会被当作 Makefile 规则的一部分发送到 shell。这里的 <code>foo_defined</code> 前面使用了两个空格符来进行缩进</p>
<h2 id="makefile-函数">Makefile 函数</h2>
<p>Makefile 可以定义函数，函数调用的展开和变量引用的展开方式相同。函数的调用语法为： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(FUNCTION ARGUMENTS)</span><br><span class="line"># 或</span><br><span class="line">$&#123;FUNCTION ARGUMENTS&#125;</span><br></pre></td></tr></table></figure> <code>FUNCTION</code> 是函数名称，如果是自定义函数，需要使用内置的 <code>call</code> 来间接调用。<code>ARGUMENTS</code> 是函数参数，多个参数用逗号隔开。Makefile 提供了很多<a href="https://www.gnu.org/software/make/manual/html_node/Functions.html">内置函数</a>，我们这里只是列出常用的几个。</p>
<p><strong>subst函数</strong> subst 是字符串替换函数，其函数签名为 <code>$(subst from,to,text)</code>。比如： <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> ee,EE,feet on the street)</span></span><br></pre></td></tr></table></figure> 替换 "feet on the street" 中的 "ee" 为 "EE"，结果为 "fEEt on the strEEt"。</p>
<p><strong>patsubst函数</strong> patsubst 函数用于模式匹配的替换，函数签名为 <code>$(patsubst pattern,replacement,text)</code>。比如下面的例子将字符串 "x.c.c bar.c" 替换成 "x.c.o bar.o"。 <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,x.c.c bar.c)</span></span><br></pre></td></tr></table></figure> <strong>wildcard函数</strong> wildcard 函数用于获取匹配模式文件名，函数签名为 <code>$(wildcard pattern)</code>。比如： <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br></pre></td></tr></table></figure> 返回值为当前目录下所有 .c 源文件列表。</p>
<h2 id="makefile-自动化变量">Makefile 自动化变量</h2>
<p>Makefile 除了常规的规则之外，还支持模式规则，模式规则最大的特点就是目标名中包含有模式字符"%"，该字符用来模糊匹配文件名。比如模式规则 <code>%.o: %.c</code>，它表示的含义是所有的 .o 文件依赖于对应的 .c 文件。因为不能使用具体的文件名，规则命令中将无法引用需要操作的文件，为了解决这个问题，Makefile 内置了一些自动化变量。</p>
<p><strong><span class="math inline">\(@** 表示 make 命令当前构建的目标名。比如： <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">a.txt b.txt:</span><br><span class="line">    touch <span class="variable">$@</span></span><br></pre></td></tr></table></figure> 在构建过程中，\)</span>@ 分别指代 a.txt 和 b.txt。等同于： <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">a.txt:</span></span><br><span class="line">    touch a.txt</span><br><span class="line"><span class="section">b.txt:</span></span><br><span class="line">    touch b.txt</span><br></pre></td></tr></table></figure> </strong><span class="math inline">\(&lt;** 规则的第一个依赖文件名。比如 `main.o: main.c util.c`，\)</span>&lt; 指代的是 main.c。</p>
<p>**<span class="math inline">\(?** 所有比目标文件更新的依赖文件列表，空格分隔。比如规则 `main.o: main.c util.c`，如果 util.c 比 main.o 更新，\)</span>? 就指代 util.c。</p>
<p>**<span class="math inline">\(^** 规则的所有依赖文件列表，空格分隔。比如规则 `main.o: main.c util.c`，\)</span>^ 指代 "main.c util.c"。</p>
<p><strong>$*</strong> <span class="math inline">\(\* 指代匹配符 % 匹配的部分，比如 % 匹配 main.c 中的 main，\)</span>* 就指代 main。</p>
<h2 id="一个例子">一个例子</h2>
<p>一个简单的 C 语言项目，分别有 main.c、util.c、util.h 三个文件，文件内容如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// util.h</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// util.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;util.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, Make!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;util.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hello();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 编写 Makefile 内容为： <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义变量</span></span><br><span class="line">objects = main.o util.o</span><br><span class="line"></span><br><span class="line"><span class="section">main: <span class="variable">$(objects)</span></span></span><br><span class="line">    cc <span class="variable">$(objects)</span> -o main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 Makefile 的隐含规则，同下面的写法：</span></span><br><span class="line"><span class="comment"># main.o:</span></span><br><span class="line"><span class="comment">#   cc -c main.c</span></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line"><span class="section">util.o: util.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义伪目标</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="comment"># 命令前的减号表示忽略rm命令出现的错误</span></span><br><span class="line">    -rm main <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure> 执行 <code>make</code>，会编译输出 main，运行 <code>./main</code>，终端会输出 <code>Hello, Make!</code>。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.gnu.org/software/make/manual/make.html">GNU make</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/02/make.html">Make 命令教程</a></li>
</ul>
]]></content>
      <categories>
        <category>Unix</category>
      </categories>
      <tags>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title>配置React Native多运行环境</title>
    <url>/react-native-multiple-environments/</url>
    <content><![CDATA[<img data-src="/react-native-multiple-environments/banner.jpg" class="">
<p>项目之初，往往需要为项目配置诸如开发环境、测试环境、生产环境等，每个环境可能都有自己的打包变量和环境变量。本文尝试为 iOS 端和 Android 端都提供一种多环境的配置方案。</p>
<a id="more"></a>
<h2 id="react-native-版本">React Native 版本</h2>
<p>本文使用的 React Native 版本为 0.61。</p>
<h2 id="构建-ios-端多环境">构建 iOS 端多环境</h2>
<p>在 iOS 中，我们使用 <strong>iOS Build Configuration</strong> 来构建多环境。使用 Xcode 打开 [projectName].xcworkplace。</p>
<h3 id="新建-configurations">新建 Configurations</h3>
<p>参照下图创建 Beta configuration。 <img data-src="/react-native-multiple-environments/iOS-configurations.png" class=""></p>
<h3 id="新建-scheme">新建 Scheme</h3>
<img data-src="/react-native-multiple-environments/iOS-scheme1.png" class="">
<p>点击该 scheme，在下拉菜单中选择 Edit Scheme，然后在弹窗中选择 Duplicate Scheme 来复制一个 scheme，将其命名为 Beta。将 Run、Test、Analyze 中的 Build Configuration 分别选择为 Beta.Debug，将 Profile 和 Archive 选择为 Beta.Release。勾选弹窗底下的 Shared 来进行分享，以便让其他开发同事也能使用到该 scheme。</p>
<img data-src="/react-native-multiple-environments/iOS-scheme2.png" class="">
<h3 id="修改-app-名称">修改 App 名称</h3>
<p>上面操作我们新建了一个 Beta configuration。对于不同环境，我们通常需要修改图标或者应用名称来表示不同。我们这里主要通过修改应用名称。对于刚刚建立的 Beta configuration，我们将应用名称配置为<code>[projectName]_β</code>。配置参照下图：</p>
<img data-src="/react-native-multiple-environments/iOS-name1.png" class="">
<p>添加名为 BUNDLE_DISPLAY_NAME_SUFFIX 的自定义项。</p>
<img data-src="/react-native-multiple-environments/iOS-name2.png" class="">
<p>打开项目的 info.plist，删除 Bundle display name，修改 Bundle name 为 <code>RN1$(BUNDLE_DISPLAY_NAME_SUFFIX)</code>。<em>注意请将其中的 <code>RN1</code> 替换为实际的应用名称。</em></p>
<p>同时修改 RN1Test 下 info.plist 的 Bundle name。如下图所示：</p>
<img data-src="/react-native-multiple-environments/iOS-name3.png" class="">
<h3 id="修改-bundle-id">修改 Bundle ID</h3>
<p>Bundle ID 用来标识应用的唯一性，如果我们希望在同一台手机中能安装同一个应用不同环境的版本，我们需要给应用在每个环境下定义不同的 Bundle ID。同样的我们增加自定义项：</p>
<img data-src="/react-native-multiple-environments/iOS-id1.png" class="">
<p>增加以下红框的内容：</p>
<img data-src="/react-native-multiple-environments/iOS-id2.png" class="">
<p>打开项目的 info.plist，修改 Bundle Identifier 为 <code>$(PRODUCT_BUNDLE_IDENTIFIER)$(BUNDLE_ID_SUFFIX)</code>。</p>
<img data-src="/react-native-multiple-environments/iOS-id3.png" class="">
<p>同时修改 RN1Tests 中 info.plist 的 Bundle identifier。</p>
<img data-src="/react-native-multiple-environments/iOS-id4.png" class="">
<h3 id="修改-podfile">修改 Podfile</h3>
<p>这一步主要是告诉 cocoapods 以下事情： - Debug 和 Release 是默认的 configurations - Beta.Debug 从 Debug 中复制 - Beta.Release 从 Release 中复制</p>
<img data-src="/react-native-multiple-environments/iOS-pod1.png" class="">
<p>内容如下： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">project &#39;RN1&#39;,</span><br><span class="line">  &#39;Debug&#39; &#x3D;&gt; :debug,</span><br><span class="line">  &#39;Release&#39; &#x3D;&gt; :release,</span><br><span class="line">  &#39;Beta.Debug&#39; &#x3D;&gt; :debug,</span><br><span class="line">  &#39;Beta.Release&#39; &#x3D;&gt; :release</span><br></pre></td></tr></table></figure> 完成之后执行命令： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd [project&#x2F;ios]</span><br><span class="line">pod install</span><br></pre></td></tr></table></figure> 到这里我们可以使用 Xcode 根据不同的 scheme 来运行项目了。</p>
<h3 id="配置-package.json-命令">配置 package.json 命令</h3>
<p>如果我们希望能从命令行中直接启动项目，可以在项目的 package.json 中增加以下命令： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;scripts&quot;: &#123;</span><br><span class="line">        ...</span><br><span class="line">        &quot;ios.beta&quot;: &quot;react-native run-ios —-simulator&#x3D;&#39;iPhone X&#39; —-scheme Beta --configuration Beta.Debug&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 构建 Android 端多环境 Android 的配置相对来说要简单的多。Android 与 iOS 的 Build Configuration 相对应的是 Build Variant。一个 Build Variant 是 Build Type 和 Product Flavor 的组合。</p>
<h3 id="添加-product-flavors">添加 Product Flavors</h3>
<p>打开项目的 android/app/build.gradle 文件，添加一个名为 productFlavors 的块，使用不同的 applicationId 来使得安装包不一样。</p>
<img data-src="/react-native-multiple-environments/android-flavor1.png" class="">
<img data-src="/react-native-multiple-environments/android-flavor2.png" class="">
<p>代码如下： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion rootProject.ext.compileSdkVersion</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    flavorDimensions &quot;default&quot;  &#x2F;&#x2F; &lt;-- !!! 要添加这行 !!!</span><br><span class="line"></span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        dev &#123;</span><br><span class="line">            minSdkVersion rootProject.ext.minSdkVersion</span><br><span class="line">            applicationId &#39;com.rn1.dev&#39;</span><br><span class="line">            targetSdkVersion rootProject.ext.targetSdkVersion</span><br><span class="line">            resValue &quot;string&quot;, &quot;build_config_package&quot;, &quot;com.myapp&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        beta &#123;</span><br><span class="line">            minSdkVersion rootProject.ext.minSdkVersion</span><br><span class="line">            applicationId &#39;com.rn1.beta&#39;</span><br><span class="line">            targetSdkVersion rootProject.ext.targetSdkVersion</span><br><span class="line">            resValue &quot;string&quot;, &quot;build_config_package&quot;, &quot;com.myapp&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 修改 App 名称 在 android/app/src/beta/res/values 目录下新建文件 strings.xml，填写以下内容： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;string name&#x3D;&quot;app_name&quot;&gt;[projectName] Beta&lt;&#x2F;string&gt;</span><br><span class="line">&lt;&#x2F;resources&gt;</span><br></pre></td></tr></table></figure> <em>注意：android/app/src/beta/res/values 该目录原本不存在，需要新建。在构建时会与 main 目录下的该文件进行合并。</em></p>
<h3 id="运行命令">运行命令</h3>
<p>主要是添加一个参数： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">—-variant&#x3D;&lt;productFlavour&gt;&lt;BuildType&gt;</span><br></pre></td></tr></table></figure> 所以如果以 debug mode 来运行 dev 版本，命令为： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">react-native run-android --variant&#x3D;devDebug --appIdSuffix&#x3D;dev</span><br></pre></td></tr></table></figure> 如果我们要发布，命令格式为： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assemble&lt;ProductFlavour&gt;&lt;BuildType&gt;</span><br></pre></td></tr></table></figure> 比如要发布一个beta版本： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd android &amp;&amp; .&#x2F;gradlew assembleBetaRelease</span><br></pre></td></tr></table></figure> ## 配置环境变量 新建不同环境配置之后，我们希望能将环境变量暴露到 js 端。</p>
<h3 id="配置-ios-端环境变量">配置 iOS 端环境变量</h3>
<p>选择 [projectName] 目录，右键打开菜单，按照下列步骤创建原生文件：</p>
<img data-src="/react-native-multiple-environments/iOS-var1.png" class="">
<img data-src="/react-native-multiple-environments/iOS-var2.png" class="">
<img data-src="/react-native-multiple-environments/iOS-var3.png" class="">
<img data-src="/react-native-multiple-environments/iOS-var4.png" class="">
<p>编辑 AppInfo.h 文件内容如下： <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;React/RCTBridge.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppInfo</span> : <span class="title">NSObject</span> &lt;<span class="title">RCTBridgeModule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure> 编辑 AppInfo.m 文件内容如下： <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;AppInfo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AppInfo</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">RCT_EXPORT_MODULE(AppInfo)</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)requiresMainQueueSetup &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">dispatch_queue_t</span>)methodQueue &#123;</span><br><span class="line">  <span class="keyword">return</span> dispatch_get_main_queue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)constantsToExport &#123;</span><br><span class="line">  <span class="built_in">NSDictionary</span> *info = [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary];</span><br><span class="line">  <span class="built_in">NSMutableDictionary</span> *settings = [[info objectForKey:<span class="string">@&quot;AppSettings&quot;</span>] mutableCopy];</span><br><span class="line">  <span class="built_in">NSString</span> *versionName = [info objectForKey:<span class="string">@&quot;CFBundleShortVersionString&quot;</span>];</span><br><span class="line">  <span class="built_in">NSNumber</span> *versionCode = [info objectForKey:<span class="string">@&quot;CFBundleVersion&quot;</span>];</span><br><span class="line">  <span class="built_in">NSString</span> *bundleId = [info objectForKey:<span class="string">@&quot;CFBundleIdentifier&quot;</span>];</span><br><span class="line">  [settings setObject:versionName forKey:<span class="string">@&quot;VERSION_NAME&quot;</span>];</span><br><span class="line">  [settings setObject:versionCode forKey:<span class="string">@&quot;VERSION_CODE&quot;</span>];</span><br><span class="line">  [settings setObject:bundleId forKey:<span class="string">@&quot;APPLICATION_ID&quot;</span>];</span><br><span class="line">  <span class="keyword">return</span> settings;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure> 我们导出了变量 <code>VERSION_NAME</code> <code>VERSION_CODE</code> <code>APPLICATION_ID</code>，稍后我们在 js 端来读取。</p>
<h3 id="配置-android-端环境变量">配置 Android 端环境变量</h3>
<p>在 android/app/src/main/java/[packageName] 下新建 <code>AppInfo.java</code> 文件，文件内容如下： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> packageName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.facebook.react.bridge.ReactApplicationContext;</span><br><span class="line"><span class="keyword">import</span> com.facebook.react.bridge.ReactContextBaseJavaModule;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Nonnull;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppInfo</span> <span class="keyword">extends</span> <span class="title">ReactContextBaseJavaModule</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppInfo</span><span class="params">(<span class="meta">@Nonnull</span> ReactApplicationContext reactContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(reactContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nonnull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;AppInfo&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getConstants</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, Object&gt; constants = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        String flavor = BuildConfig.FLAVOR;</span><br><span class="line">        String env = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;dev&quot;</span>.equals(flavor)) &#123;</span><br><span class="line">            env = <span class="string">&quot;development&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;beta&quot;</span>.equals(flavor)) &#123;</span><br><span class="line">            env = <span class="string">&quot;beta&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;prod&quot;</span>.equals(flavor)) &#123;</span><br><span class="line">            env = <span class="string">&quot;production&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        constants.put(<span class="string">&quot;ENVIRONMENT&quot;</span>, env);</span><br><span class="line">        constants.put(<span class="string">&quot;VERSION_NAME&quot;</span>, BuildConfig.VERSION_NAME);</span><br><span class="line">        constants.put(<span class="string">&quot;VERSION_CODE&quot;</span>, BuildConfig.VERSION_CODE);</span><br><span class="line">        constants.put(<span class="string">&quot;APPLICATION_ID&quot;</span>, BuildConfig.APPLICATION_ID);</span><br><span class="line">        <span class="keyword">return</span> constants;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 再新建 <code>AppPackage.java</code> 文件，内容如下： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> packageName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.annotation.NonNull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.facebook.react.ReactPackage;</span><br><span class="line"><span class="keyword">import</span> com.facebook.react.bridge.NativeModule;</span><br><span class="line"><span class="keyword">import</span> com.facebook.react.bridge.ReactApplicationContext;</span><br><span class="line"><span class="keyword">import</span> com.facebook.react.uimanager.ViewManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppPackage</span> <span class="keyword">implements</span> <span class="title">ReactPackage</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;NativeModule&gt; <span class="title">createNativeModules</span><span class="params">(<span class="meta">@NonNull</span> ReactApplicationContext reactContext)</span> </span>&#123;</span><br><span class="line">        List&lt;NativeModule&gt; modules = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        modules.add(<span class="keyword">new</span> AppInfo(reactContext));</span><br><span class="line">        <span class="keyword">return</span> modules;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ViewManager&gt; <span class="title">createViewManagers</span><span class="params">(<span class="meta">@NonNull</span> ReactApplicationContext reactContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 修改 <code>MainApplication.java</code> 文件，添加我们自定义的模块： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;ReactPackage&gt; <span class="title">getPackages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.&lt;ReactPackage&gt;asList(</span><br><span class="line">            <span class="keyword">new</span> MainReactPackage(),</span><br><span class="line">            <span class="comment">// 添加自定义的package</span></span><br><span class="line">            <span class="keyword">new</span> AppPackage()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure> ### 在 js 端读取环境变量 在 RN 项目下新建文件 <code>config.js</code>，内容如下： <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NativeModules &#125; <span class="keyword">from</span> <span class="string">&#x27;react-native&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; AppInfo &#125; = NativeModules;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> AppInfo;</span><br></pre></td></tr></table></figure> ## 参考资源 - https://github.com/thekevinbrown/react-native-schemes-manager/issues/76 - https://medium.com/<span class="citation" data-cites="ywongcode/building-multiple-versions-of-a-react-native-app-4361252ddde5">@ywongcode/building-multiple-versions-of-a-react-native-app-4361252ddde5</span> - https://juejin.im/post/5d18b0ba6fb9a07ed524b592</p>
]]></content>
      <categories>
        <category>大前端</category>
      </categories>
      <tags>
        <tag>React Native</tag>
        <tag>多环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift高级</title>
    <url>/swift-advanced/</url>
    <content><![CDATA[<p>本文介绍Swift语言的枚举、结构体、类、协议和扩展等相关知识。</p>
<a id="more"></a>
<h2 id="枚举">枚举</h2>
<p>通过<code>enum</code>语法来定义一个枚举： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Direction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> north</span><br><span class="line">    <span class="keyword">case</span> south</span><br><span class="line">    <span class="keyword">case</span> east</span><br><span class="line">    <span class="keyword">case</span> west</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 与C、Java等语言的枚举不同，Swift的枚举没有底层的整型，如果想让Swift的枚举具有相同的功能，可以给枚举设置一个原始值。这里值得注意的是每个case子句的原始值不能相同。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为每个case子句赋值，注意原始值不能相同</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Direction</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> north <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> south <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">case</span> east <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">case</span> west <span class="operator">=</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们也没有必要像上面那样为每个case子句赋值，Swift支持隐形赋值</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Direction</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> north <span class="operator">=</span> <span class="number">1</span>, south, east, west</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 除了原始值，枚举还支持关联值，关联值相当于是枚举中的额外信息。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们定义一个Person枚举，fullName和shortName都具有一个String的关联值</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> fullName(<span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> shortName(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p <span class="operator">=</span> <span class="type">Person</span>.fullName(<span class="string">&quot;gcfeng&quot;</span>)</span><br><span class="line"><span class="comment">// 编译器可以推断出p是Person类型，所以这里省略了Person前缀</span></span><br><span class="line">p <span class="operator">=</span> .shortName(<span class="string">&quot;gc&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用switch语句可以取出关联值</span></span><br><span class="line"><span class="keyword">switch</span> p &#123;</span><br><span class="line">  <span class="keyword">case</span> .fullName(<span class="keyword">let</span> name):</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">  <span class="keyword">case</span> .shortName(<span class="keyword">let</span> name):</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 枚举还支持递归，不过要使用递归枚举，我们需要使用<code>indirect</code>关键字来告诉编译器。因为Swift编译器需要知道每个实例占据多少空间，而递归枚举是无限循环的，无法计算所需内存空间，<code>indirect</code>关键字告诉编译器将枚举的数据放到一个指针指向的地方。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个递归枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> number(<span class="type">Int</span>)</span><br><span class="line">  <span class="keyword">indirect</span> <span class="keyword">case</span> add(<span class="type">Expression</span>, <span class="type">Expression</span>)</span><br><span class="line">  <span class="keyword">indirect</span> <span class="keyword">case</span> multiply(<span class="type">Expression</span>, <span class="type">Expression</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果所有成员都是可递归的，我们可以将indirect提到enum前面</span></span><br><span class="line"><span class="keyword">indirect</span> <span class="class"><span class="keyword">enum</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> number(<span class="type">Int</span>)</span><br><span class="line">  <span class="keyword">case</span> add(<span class="type">Expression</span>, <span class="type">Expression</span>)</span><br><span class="line">  <span class="keyword">case</span> multiply(<span class="type">Expression</span>, <span class="type">Expression</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数来使用递归枚举</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evaluate</span><span class="params">(<span class="keyword">_</span> expression: Expression)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> expression &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .number(value):</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .add(left, right):</span><br><span class="line">      <span class="keyword">return</span> evaluate(left) <span class="operator">+</span> evaluate(right)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .multiply(left, right):</span><br><span class="line">      <span class="keyword">return</span> evaluate(left) <span class="operator">*</span> evaluate(right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a <span class="operator">=</span> <span class="type">Expression</span>.number(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> b <span class="operator">=</span> <span class="type">Expression</span>.number(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> sum <span class="operator">=</span> <span class="type">Expression</span>.add(a, b)</span><br><span class="line">evaluate(sum)  <span class="comment">// 输出：3</span></span><br></pre></td></tr></table></figure> ## 结构体和类 结构体和类都提供了面向对象编程的抽象封装能力。在Swift中，结构体的使用要简单的多，如果不涉及继承等复杂场景，推荐使用结构体。使用<code>struct</code>来定义结构体，使用<code>class</code>来定义类。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Resolution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> height <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoMode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> resolution <span class="operator">=</span> <span class="type">Resolution</span>()</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化实例</span></span><br><span class="line"><span class="keyword">var</span> r <span class="operator">=</span> <span class="type">Resolution</span>()</span><br><span class="line"><span class="keyword">var</span> v <span class="operator">=</span> <span class="type">VideoMode</span>()</span><br></pre></td></tr></table></figure> 我们可以给结构体和类定义类型方法，类型方法是类型本身来调用，这个有点像Java中的静态方法。但是结构体和类对于类型方法的声明关键字并不一样。结构体使用<code>static</code>来定义，类使用<code>class</code>来定义。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Resolution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> height <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">printMsg</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;resolution&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoMode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> resolution <span class="operator">=</span> <span class="type">Resolution</span>()</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">printMsg</span>() </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;videoMode&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型本身来调用</span></span><br><span class="line"><span class="type">Resolution</span>.printMsg()</span><br><span class="line"><span class="type">VideoMode</span>.printMsg()</span><br></pre></td></tr></table></figure> 对于<code>VideoMode</code>类而言，如果不希望子类重写<code>printMsg</code>方法，可以使用<code>final class</code>来修饰<code>printMsg</code>，或者使用<code>static</code>来修饰<code>printMsg</code>。</p>
<p>结构体中的方法默认不能修改属性值，比如上面<code>Resolution</code>中的<code>printMsg</code>。如果希望结构体中的方法能修改属性值，需要在方法声明中加上<code>mutating</code>关键字。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> age <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">  <span class="keyword">var</span> name <span class="operator">=</span> <span class="string">&quot;gc&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">addAge</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.age <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line">p.addAge()</span><br></pre></td></tr></table></figure> 与JavaScript类似的，Swift将属性分为存储属性和计算属性。存储属性可用于类和结构体，计算属性可用于枚举、结构体和类。存储属性和计算属性的区别在于，存储属性实际保存值，计算属性不实际保存值。值得注意的是，Swift为属性增加了<code>willSet</code>和<code>didSet</code>观察器，当修改属性值时，会触发属性观察器，应用此特性，可以很方便的实现前端的MVVM功能。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 存储属性</span></span><br><span class="line">  <span class="keyword">var</span> name <span class="operator">=</span> <span class="string">&quot;gc&quot;</span></span><br><span class="line">  <span class="comment">// 存储属性，同时定义了didSet观察器</span></span><br><span class="line">  <span class="comment">// 当age完成修改时，会触发didSet函数</span></span><br><span class="line">  <span class="keyword">var</span> age <span class="operator">=</span> <span class="number">20</span> &#123;</span><br><span class="line">    didSet(oldAge) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;The age has changed to <span class="subst">\(age)</span> from <span class="subst">\(oldAge)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 计算属性</span></span><br><span class="line">  <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;<span class="subst">\(name)</span> is <span class="subst">\(age)</span> years old&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line">p.age <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(p.description)</span><br></pre></td></tr></table></figure> ## 构造过程和析构过程 我们之前定义的结构体和类，都默认给属性赋了初始值，这是初始化的一种方式。实际上，我们可以通过构造器来给属性赋值。使用<code>init</code>来定义构造器，语法如下： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意这里没有使用func来修饰</span></span><br><span class="line"><span class="keyword">init</span>(parameter: <span class="type">SomeType</span>) &#123;</span><br><span class="line">  <span class="comment">// 初始化代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> Swift为类的构造过程提供了两种构造器，分别是指定（designated）构造器和便利（convenience）构造器。这两种构造器有几个使用原则： - 一个指定构造器必须调用它直系父类的一个指定构造器 - 一个便利构造器必须调用这个类自身的另一个构造器 - 一个便利构造器最终一定会调用一个指定构造器</p>
<p>Swift通过便利构造器给一些属性赋默认值，从而达到简化参数传递个数的目的。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    <span class="keyword">self</span>.age <span class="operator">=</span> age</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">convenience</span> <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(name: name, age: <span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;gc&quot;</span>)</span><br></pre></td></tr></table></figure> 析构过程是构造过程的反面，是在类的实例没用之后将其清除出内存的过程，只适用于类。每个类最多只能有一个析构器，析构器的定义如下： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">  <span class="comment">// 释放额外的引用资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 协议 协议能让你定义类型需要满足的接口，满足某个协议的类型被称为符合这个协议。协议不仅能定义符合该协议的类型必须提供的属性和方法，自己还能作为类型使用，变量、函数参数和返回值都可以把协议作为类型。结构体、枚举、类都可以符合协议。一个类型可以符合多个协议，如果类有父类，父类的名字在前，然后再跟协议。Swift中的协议与Java语言的接口很像。Mac和iOS应用通常都把数据的展现和提供数据的源分离。利用协议，我们可以很好的做到这一点。</p>
<p>使用<code>protocol</code>来定义一个协议： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义了一个协议DataSource</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 符合DataSource协议的类型必须要有numberOfRows和numberOfColumns两个属性</span></span><br><span class="line">  <span class="comment">// DataSource协议并不要求对这两个属性可写，所以在后面写上了&#123; get &#125;，表示只读就行</span></span><br><span class="line">  <span class="keyword">var</span> numberOfRows: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">var</span> numberOfColumns: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">label</span><span class="params">(forColumn column: Int)</span></span> -&gt; <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">itemFor</span><span class="params">(row: Int, column: Int)</span></span> -&gt; <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 下面来定义结构体使用上述协议： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> age: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让Department符合DataSource协议</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Department</span>: <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> people: [<span class="type">Person</span>]()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="keyword">_</span> person: Person)</span></span> &#123;</span><br><span class="line">    people.append(person)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Mark: DataSource</span></span><br><span class="line">  <span class="comment">// 实现协议定义的属性和方法</span></span><br><span class="line">  <span class="keyword">var</span> numberOfRows: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> people.count</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> numberOfColumns: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">label</span><span class="params">(forColumn column: Int)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> column &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> <span class="string">&quot;Name&quot;</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="string">&quot;Age&quot;</span></span><br><span class="line">      <span class="keyword">default</span>: <span class="built_in">fatalError</span>(<span class="string">&quot;Invalid column!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">itemFor</span><span class="params">(row: Int, column: Int)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> person <span class="operator">=</span> people[row]</span><br><span class="line">    <span class="keyword">switch</span> column &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> person.name</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="type">String</span>(person.age)</span><br><span class="line">      <span class="keyword">default</span>: <span class="built_in">fatalError</span>(<span class="string">&quot;Invalid column!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> department <span class="operator">=</span> <span class="type">Department</span>(name: <span class="string">&quot;Engineering&quot;</span>)</span><br><span class="line">department.add(<span class="type">Person</span>(name: <span class="string">&quot;a&quot;</span>, age: <span class="number">20</span>))</span><br></pre></td></tr></table></figure> ## 扩展 扩展可以给一个现有的类、结构体、枚举，还有协议添加新的功能。Swift的扩展可以： - 添加计算属性 - 添加新初始化方法 - 使类型符合协议 - 添加新方法 - 添加嵌入类型</p>
<p>下面我们扩展已有的<code>Double</code>类型： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扩展Double类型，添加一个km属性</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Double</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> km: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">/</span> <span class="number">1000.0</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d <span class="operator">=</span> <span class="number">100.0</span></span><br><span class="line"><span class="built_in">print</span>(d.km)</span><br></pre></td></tr></table></figure> <em>值得注意的是扩展不允许为类型添加存储属性。</em></p>
<h2 id="泛型">泛型</h2>
<p>泛型是面向对象编程中实现多态的工具，Swift中的泛型与Java等语言的泛型非常类似。比如定义一个类的泛型： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义了一个Stack数据结构，Element是占位类型</span></span><br><span class="line"><span class="comment">// 在实例化类型的时候会特化具体类型，比如 var a = Stack&lt;Int&gt;()</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> items <span class="operator">=</span> [<span class="type">Element</span>]()</span><br><span class="line">  <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 为了能对占位类型有所假设，类似Java为泛型定义的上下界，Swift可以为泛型定义两种类型约束：一种是类型必须是给定类的子类，还有一种是类型必须符合一个协议（或者一个协议组合）。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 让占位类型T符合Equatable协议</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkIfEqual</span>&lt;T: Equatable&gt;<span class="params">(<span class="keyword">_</span> first: T, <span class="keyword">_</span> second: T)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> first <span class="operator">==</span> second</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Swift面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift基础</title>
    <url>/swift-basic/</url>
    <content><![CDATA[<p>本文介绍Swift语言的基础内容，主要包括数据类型、流程控制、集合类型、函数和闭包等。</p>
<a id="more"></a>
<h2 id="数据类型">数据类型</h2>
<h3 id="基本数据类型">基本数据类型</h3>
<p>Swift包含了C和Objective-C上所有的基础数据类型： - Int：整数，无符号类型使用UInt。在32位平台上，Int与Int32长度相同；在64位平台上，Int与Int64长度相同 - Float：32位浮点数 - Double：64位浮点数 - Bool：布尔值 - Character：字符 - String：字符串，是字符的集合</p>
<p>字符串是我们平常开发中频繁使用的数据类型，Swift也给字符串封装了相当多的功能。常见的比如字符串插值： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a <span class="operator">=</span> <span class="string">&quot;gcfeng&quot;</span></span><br><span class="line"><span class="keyword">let</span> s <span class="operator">=</span> <span class="string">&quot;hello <span class="subst">\(a)</span>&quot;</span>  <span class="comment">// 输出：hello gcfeng</span></span><br></pre></td></tr></table></figure> 也可以通过<code>for-in</code>循环来遍历字符串的每一个字符： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> s &#123;</span><br><span class="line">  <span class="built_in">print</span>(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 常量与变量 如果熟悉TypeScript，会发现两者声明变量的方式很像。不同的是，Swift中使用<code>let</code>来定义常量，使用<code>var</code>来定义变量。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用let来声明常量，使用var来声明变量</span></span><br><span class="line"><span class="keyword">let</span> s: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Swift支持类型推断，这里推断出v是整型。类型推断可以在声明变量时省略类型声明</span></span><br><span class="line"><span class="keyword">var</span> v <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Swift是类型安全的，v是整型，这里将字符串赋值给整型变量会报错</span></span><br><span class="line">v <span class="operator">=</span> <span class="string">&quot;error&quot;</span></span><br></pre></td></tr></table></figure> ### 元组 除了上面基础的数据类型，Swift还增加了元组。元组将多个值组合成了一个复合值。元组内的值可以是任意类型，比如<code>(200, "OK")</code>是一个被描述为<code>(Int, String)</code>类型的元组。元组在函数有多个返回值时会非常有用。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个元组</span></span><br><span class="line"><span class="keyword">let</span> httpCode <span class="operator">=</span> (<span class="number">200</span>, <span class="string">&quot;OK&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构赋值，与ES类似</span></span><br><span class="line"><span class="keyword">let</span> (status, code) <span class="operator">=</span> httpCode</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过下标来访问元组的值</span></span><br><span class="line"><span class="built_in">print</span>(httpCode.<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(httpCode.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以定义命名元组</span></span><br><span class="line"><span class="keyword">let</span> namedHttpCode <span class="operator">=</span> (status: <span class="number">200</span>, code: <span class="string">&quot;OK&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(namedHttpCode.status)</span><br><span class="line"><span class="built_in">print</span>(namedHttpCode.code)</span><br></pre></td></tr></table></figure> ### 可空类型 可空类型（optional）用来指定某个实例要么有值可用，要么没有值为nil。在Objective-C中，nil表示一个指向不存在对象的指针，然而在Swift中，nil是一个确定的值。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明可空类型。这里没有赋值，默认就是nil</span></span><br><span class="line"><span class="keyword">var</span> str: <span class="type">String</span>?</span><br><span class="line">str <span class="operator">=</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果我们确定str有值，可以使用!强制展开，否则会报错</span></span><br><span class="line"><span class="keyword">let</span> val <span class="operator">=</span> str<span class="operator">!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用if语句来展开，如果str为nil，不会进入到条件语句内部</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> val <span class="operator">=</span> str &#123;</span><br><span class="line">  <span class="built_in">print</span>(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 另外一种声明可空类型的方式是在变量名的后面加上<code>!</code>。这种方式定义的可空类型与普通的相比只是不需要展开。通常这种方式只在类的初始化中使用。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str: <span class="type">String</span>!</span><br><span class="line"></span><br><span class="line"><span class="comment">// str为nil，直接赋值给str2会报错</span></span><br><span class="line"><span class="keyword">let</span> str2: <span class="type">String</span> <span class="operator">=</span> str</span><br><span class="line"></span><br><span class="line"><span class="comment">// str3的类型会演变为String?</span></span><br><span class="line"><span class="keyword">let</span> str3 <span class="operator">=</span> str</span><br></pre></td></tr></table></figure> 可空类型的一个常见处理操作是：要么获取其值，要么使用一个默认值。比如： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str: <span class="type">String</span>?</span><br><span class="line"><span class="keyword">let</span> str2: <span class="type">String</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> v <span class="operator">=</span> str &#123;</span><br><span class="line">  str2 <span class="operator">=</span> v</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  str2 <span class="operator">=</span> <span class="string">&quot;defualt value&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用下面这条语句来完成上面的功能</span></span><br><span class="line"><span class="keyword">let</span> str2 <span class="operator">=</span> str <span class="operator">??</span> <span class="string">&quot;default value&quot;</span></span><br></pre></td></tr></table></figure> ## 流程控制 Swift语言提供的流程控制语句大多与其他语言类似，不再赘述。这里只是列出一些值得注意的地方。首先Swift语言中的判断语句和循环语句都需要带上花括号： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> someValue <span class="operator">&gt;</span> <span class="number">1</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>for-in</code>循环可以遍历数字范围： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历1到5</span></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">5</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(index)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果我们不需要区间序列内的值，可以使用下划线来代替</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">5</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(index)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时另外的区间运算符也是支持的</span></span><br><span class="line"><span class="comment">// 遍历1到4</span></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span><span class="operator">..&lt;</span><span class="number">5</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(index)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设names是一个数组，这里从names的第二项开始遍历</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[<span class="number">2</span><span class="operator">...</span>] &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(name)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>switch</code>语句做了增强，<code>case</code>子句可以匹配多种不同模式： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> statusCode <span class="operator">=</span> <span class="number">400</span></span><br><span class="line"><span class="keyword">let</span> errorString <span class="operator">=</span> <span class="string">&quot;The request failed.&quot;</span></span><br><span class="line"><span class="comment">// 注意到每一个case子句没有写break，当匹配到一个case子句时，Swift默认执行完就会跳出</span></span><br><span class="line"><span class="keyword">switch</span> statusCode &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">100</span>, <span class="number">101</span>:</span><br><span class="line">    errorString <span class="operator">+=</span> <span class="string">&quot; Informational, 1xx.&quot;</span></span><br><span class="line"><span class="comment">// case子句支持区间运算符</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">300</span><span class="operator">...</span><span class="number">307</span>:</span><br><span class="line">    errorString <span class="operator">+=</span> <span class="string">&quot; Redirection, 3xx.&quot;</span></span><br><span class="line"><span class="comment">// case子句支持值匹配，将statusCode赋值给unknowCode</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> unknownCode:</span><br><span class="line">    <span class="comment">// unknownCode常量只能在该分支中使用</span></span><br><span class="line">    errorString <span class="operator">+=</span> <span class="string">&quot;<span class="subst">\(unknownCode)</span> is not a known error code.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是更加复杂的情景</span></span><br><span class="line"><span class="keyword">switch</span> statusCode &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">100</span>, <span class="number">101</span>:</span><br><span class="line">    errorString <span class="operator">+=</span> <span class="string">&quot; Informational, 1xx.&quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">300</span><span class="operator">...</span><span class="number">307</span>:</span><br><span class="line">    errorString <span class="operator">+=</span> <span class="string">&quot; Redirection, 3xx.&quot;</span></span><br><span class="line"><span class="comment">// 使用where子句</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> unknownCode <span class="keyword">where</span> (unknownCode <span class="operator">&gt;=</span> <span class="number">200</span> <span class="operator">&amp;&amp;</span> unknownCode <span class="operator">&lt;</span> <span class="number">300</span>) <span class="operator">||</span> unknownCode <span class="operator">&gt;</span> <span class="number">505</span>:</span><br><span class="line">    <span class="comment">// unknownCode常量只能在该分支中使用</span></span><br><span class="line">    errorString <span class="operator">+=</span> <span class="string">&quot;<span class="subst">\(unknownCode)</span> is not a known error code.&quot;</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    errorString <span class="operator">=</span> <span class="string">&quot;Unexpected error&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 集合类型 Swift语言提供了数组（Array）、集合（Set）和字典（Dictionary）三种基本的集合类型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">var</span> arr <span class="operator">=</span> [<span class="type">Int</span>]()</span><br><span class="line">arr.append(<span class="number">4</span>)</span><br><span class="line">arr.append(<span class="number">3</span>)</span><br><span class="line">arr[<span class="number">0</span>] <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">arr.remove(at: <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> arr &#123;</span><br><span class="line">  <span class="built_in">print</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合</span></span><br><span class="line"><span class="keyword">var</span> set1 <span class="operator">=</span> <span class="type">Set</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"><span class="keyword">var</span> set2 <span class="operator">=</span> <span class="type">Set</span>([<span class="string">&quot;Apples&quot;</span>, <span class="string">&quot;Oranges&quot;</span>, <span class="string">&quot;Pineapple&quot;</span>])</span><br><span class="line"><span class="keyword">for</span> food <span class="keyword">in</span> set2 &#123;</span><br><span class="line">    <span class="built_in">print</span>(food)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> set3 <span class="operator">=</span> <span class="type">Set</span>([<span class="string">&quot;Apples&quot;</span>, <span class="string">&quot;Bananas&quot;</span>, <span class="string">&quot;Cereal&quot;</span>])</span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="built_in">print</span>(set2.union(set3))</span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="built_in">print</span>(set2.intersection(set3))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字典</span></span><br><span class="line"><span class="keyword">var</span> dict1: <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">Double</span>&gt; <span class="operator">=</span> [:]</span><br><span class="line"><span class="keyword">var</span> dict2 <span class="operator">=</span> <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">Double</span>&gt;()</span><br><span class="line"><span class="keyword">var</span> dict3: [<span class="type">String</span>:<span class="type">Double</span>] <span class="operator">=</span> [:]</span><br><span class="line"><span class="keyword">var</span> dict4 <span class="operator">=</span> [<span class="type">String</span>:<span class="type">Double</span>]()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dict5 <span class="operator">=</span> [<span class="string">&quot;one&quot;</span>: <span class="number">1</span>, <span class="string">&quot;two&quot;</span>: <span class="number">2</span>]</span><br><span class="line"><span class="keyword">var</span> dictNum <span class="operator">=</span> dict5[<span class="string">&quot;one&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> dict5 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(key)</span>: <span class="subst">\(value)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数">函数</h2>
<p>作为现代语言，Swift的函数语法非常灵活。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sayHello1函数定义了一个函数参数，其中to为外部参数，name为内部参数，</span></span><br><span class="line"><span class="comment">// to和name是同一个参数在函数内外的不同名字</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello1</span><span class="params">(to name: String)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello <span class="subst">\(name)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">sayHello1(to: <span class="string">&quot;gc&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变长参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello2</span><span class="params">(to names: String...)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello <span class="subst">\(name)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sayHello2(to: <span class="string">&quot;gc&quot;</span>, <span class="string">&quot;nan&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认参数</span></span><br><span class="line"><span class="comment">// 默认参数应该放在函数参数列表的末尾。如果形参有默认值，那么在调用函数时可以省略实参。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello3</span><span class="params">(to name: String, greeting: String = <span class="string">&quot;Hello&quot;</span>)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(greeting)</span>: <span class="subst">\(name)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">sayHello3(to: <span class="string">&quot;gc&quot;</span>)  <span class="comment">// greeting参数使用默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in-out参数</span></span><br><span class="line"><span class="comment">// in-out参数能让函数修改函数体以外的变量。有两个注意点：</span></span><br><span class="line"><span class="comment">// 1、in-out参数不能有默认值</span></span><br><span class="line"><span class="comment">// 2、变长参数不能标记为inout</span></span><br><span class="line"><span class="keyword">var</span> error <span class="operator">=</span> <span class="string">&quot;The request failed:&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendError</span><span class="params">(<span class="keyword">_</span> code: Int, toErrorString errorString: <span class="keyword">inout</span> String)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> code <span class="operator">==</span> <span class="number">400</span> &#123;</span><br><span class="line">        errorString <span class="operator">+=</span> <span class="string">&quot; bad request.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">appendError(<span class="number">400</span>, toErrorString: <span class="operator">&amp;</span>error) <span class="comment">// 这里很像C语言传递了个引用，函数内部就可以修改error的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">areaOfTriangleWith</span><span class="params">(base: Double, height: Double)</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> num <span class="operator">=</span> base <span class="operator">*</span> height</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">()</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> divide()</span><br><span class="line">&#125;</span><br><span class="line">areaOfTriangleWith(base: <span class="number">3.0</span>, height: <span class="number">5.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提前退出函数：guard</span></span><br><span class="line"><span class="comment">// guard语句判断某些条件没有满足时，会提前退出函数。</span></span><br><span class="line"><span class="comment">// 其实使用if语句也能达到同样的效果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello4</span><span class="params">(to name: String?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> n <span class="operator">=</span> name <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;No name&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello <span class="subst">\(n)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">sayHello4(to: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<h2 id="闭包">闭包</h2>
<p>闭包是自包含的函数代码块，是一种引用类型，可以在代码中被传递和引用。闭包可以捕获和存储其所在上下文中任意常量和变量的引用。闭包表达式的一般语法为： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&#123;(params) -&gt; <span class="keyword">return</span> type <span class="keyword">in</span></span><br><span class="line">  <span class="comment">// body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> Swift语言的闭包表达式鼓励在常见场景中进行语法优化，下面是逐步优化的场景： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先定义一个数组</span></span><br><span class="line"><span class="keyword">let</span> numbers <span class="operator">=</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">40</span>, <span class="number">5</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法1</span></span><br><span class="line"><span class="keyword">let</span> numbersSorted <span class="operator">=</span> numbers.sorted(by: &#123;</span><br><span class="line">    (i: <span class="type">Int</span>, j: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> i <span class="operator">&lt;</span> j</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法2：利用类型推断系统来简化代码</span></span><br><span class="line"><span class="keyword">let</span> numbersSorted <span class="operator">=</span> numbers.sorted(by: &#123; i, j <span class="keyword">in</span> i <span class="operator">&lt;</span> j &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法3：编译器的类型推断可以知道闭包接受的参数个数和类型，这意味着不需要给参数命名</span></span><br><span class="line"><span class="comment">// 使用$0引用第一个参数值，$1引用第二个参数值</span></span><br><span class="line"><span class="keyword">let</span> numbersSorted <span class="operator">=</span> numbers.sorted(by: &#123; <span class="variable">$0</span> <span class="operator">&lt;</span> <span class="variable">$1</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法4：如果一个闭包是以一个函数的最后一个参数传递的，那么它就可以在函数的圆括号以外内联。</span></span><br><span class="line"><span class="comment">// 这种方式也叫做尾随闭包优化。</span></span><br><span class="line"><span class="keyword">let</span> numbersSorted <span class="operator">=</span> numbers.sorted &#123; <span class="variable">$0</span> <span class="operator">&lt;</span> <span class="variable">$1</span> &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Swift基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift多线程</title>
    <url>/swift-multithread/</url>
    <content><![CDATA[<p>本文介绍三种不同的多线程技术，分别是Thread、Grand Central Dispatch(GCD)和Operation。</p>
<a id="more"></a>
<h2 id="thread">Thread</h2>
<p>Thread在三种多线程技术中是最轻量级的，但需要自己来管理线程的生命周期和同步问题。Thread有两种创建方式： - 通过工厂方法直接创建线程并自动运行 - 先创建一个线程对象，然后手动运行线程</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、使用类方法</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run1</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Thread1 start&quot;</span>)</span><br><span class="line">        <span class="type">Thread</span>.detachNewThreadSelector(<span class="keyword">#selector</span>(longRunningTask), toTarget: <span class="keyword">self</span>, with: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2、使用构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run2</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Thread2 start&quot;</span>)</span><br><span class="line">        <span class="keyword">let</span> thread <span class="operator">=</span> <span class="type">Thread</span>(target: <span class="keyword">self</span>, selector: <span class="keyword">#selector</span>(longRunningTask), object: <span class="literal">nil</span>)</span><br><span class="line">        <span class="comment">// 需要手动启动</span></span><br><span class="line">        thread.start()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">longRunningTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="number">5</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> threadTest <span class="operator">=</span> <span class="type">ThreadTest</span>()</span><br><span class="line">threadTest.run1()</span><br><span class="line">threadTest.run2()</span><br></pre></td></tr></table></figure>
<h2 id="grand-central-dispatchgcd">Grand Central Dispatch(GCD)</h2>
<p>GCD的基本概念是将任务添加到调度队列中，队列中的任务稍后会以先到先执行的顺序执行。任务分为同步任务和异步任务，同步任务会阻塞当前线程，直到任务完成。异步任务不会等待任务执行结束，而是马上返回到当前线程继续执行下一个任务。队列也分为串行队列和并发队列，串行队列在任何时刻都只有一个任务被执行，并发队列可能会有多个任务并发执行，这依赖于系统环境。</p>
<h3 id="队列">队列</h3>
<p>使用<code>DispatchQueue</code>来新建调度队列，新建后系统会为该队列分配线程。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用独一无二的label参数来表示队列意图</span></span><br><span class="line"><span class="comment">// 默认创建的是串行队列</span></span><br><span class="line"><span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">DispatchQueue</span>(label: <span class="string">&quot;com.gcfeng.networking&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果要创建并发队列，可以传递attributes参数</span></span><br><span class="line"><span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">DispatchQueue</span>(label: <span class="string">&quot;com.gcfeng.networking&quot;</span>, attributes: .concurrent)</span><br></pre></td></tr></table></figure> 应用启动后，程序会默认创建一个主调度队列（main dispatch queue），主调度队列是一个串行队列，负责UI渲染，通过<code>DispatchQueue.main</code>可以访问该主队列。需要注意的是不要在主队列中执行同步任务，除非这些任务是更新UI的，否则可能会造成界面卡顿。</p>
<p>任务有优先级，优先级高的会先执行，分配有更多资源，但是也希望执行时间尽可能快。系统使用QoS(Quality of Service)来描述优先级，共定义了6种不同的QoS： - .userInteractive：用户交互的任务，比如动画或任何希望UI快速更新的任务。优先级最高 - .userInitiated：需要马上获取结果，比如打开一个文档或者从本地数据库中读取记录 - .utility：可以执行很长时间，然后通知用户结果。比如文件下载，给用户下载进度 - .background：耗时较久的任务，且用户并不关心完成时间。比如后台数据同步等 - .default和.unspecified：.default是默认值，介于.userInitiated和.userInteractive之间。.unspecified是为了兼容旧API的。这两个值都不推荐直接使用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在创建队列的时候，可以传递qos参数来指定队列的优先级</span></span><br><span class="line"><span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">DispatchQueue</span>(label: <span class="string">&quot;com.gcfeng.doc&quot;</span>, qos: .userInitiated, attributes: .concurrent)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不希望自己管理，可以获取系统预定义的全局并发队列：</span></span><br><span class="line"><span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">DispatchQueue</span>.global(qos: .userInitiated)</span><br></pre></td></tr></table></figure>
<h3 id="任务">任务</h3>
<p>任务是一段闭包代码。队列使用sync来创建同步任务，使用async来创建异步任务： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建了异步任务</span></span><br><span class="line"><span class="type">DispatchQueue</span>.global(qos: .utility).async &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">  <span class="comment">// [weak self]表示我们弱引用self变量，那么在使用self变量之前需要进行检查</span></span><br><span class="line">  <span class="comment">// 实际上GCD的异步任务不会造成循环引用，所以这里是否使用弱引用因需求而定</span></span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> <span class="operator">=</span> <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行任务代码</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 回到主线程来更新UI</span></span><br><span class="line">  <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">    <span class="keyword">self</span>.textLabel.text <span class="operator">=</span> <span class="string">&quot;New post available!&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 组 可以将队列中的任务分组，当组内所有任务都完成时发出通知。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GCDTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 新建一个队列</span></span><br><span class="line">    <span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">DispatchQueue</span>(label: <span class="string">&quot;com.gcfeng.test&quot;</span>, attributes: .concurrent)</span><br><span class="line">    <span class="comment">// 新建一个组</span></span><br><span class="line">    <span class="keyword">let</span> group <span class="operator">=</span> <span class="type">DispatchGroup</span>()</span><br><span class="line">    queue.async(group: group) &#123;</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;task1: <span class="subst">\(i)</span>&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    queue.async(group: group) &#123;</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;task2: <span class="subst">\(i)</span>&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当组内的任务全部完成时，通知主线程</span></span><br><span class="line">    group.notify(queue: <span class="type">DispatchQueue</span>.main) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;All task finish&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> gcdTest <span class="operator">=</span> <span class="type">GCDTest</span>()</span><br><span class="line">gcdTest.run()</span><br></pre></td></tr></table></figure> 如果任务代码中包含异步方法，任务不会等待里面的异步方法执行完毕就返回了，而队列却又认为任务已经执行完毕，这样就出现问题了。组提供了enter和leave方法来解决这个问题，例如： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">asyncAdd</span><span class="params">(lhs: Int, rhs: Int, completion: @escaping <span class="params">(Int)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">  <span class="comment">// 一些代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 完成后执行逃逸闭包</span></span><br><span class="line">  completion(lhs <span class="operator">+</span> rhs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">asyncAddForGroup</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  group: DispatchGroup, </span></span></span><br><span class="line"><span class="function"><span class="params">  lhs: Int, </span></span></span><br><span class="line"><span class="function"><span class="params">  rhs: Int, </span></span></span><br><span class="line"><span class="function"><span class="params">  completion: @escaping <span class="params">(Int)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">  <span class="comment">// 表示开始进入异步方法  </span></span><br><span class="line">  group.enter()</span><br><span class="line">  asyncAdd(lhs: lhs, rhs: rhs) &#123; result <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// 确保一定会进入leave，通知异步方法执行结束</span></span><br><span class="line">    <span class="keyword">defer</span> &#123; group.leave() &#125;</span><br><span class="line">    completion(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 信号量 信号量可以控制资源的并发访问。以下代码会顺序输出0到9： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建信号量，1表示最多只能1个线程访问资源</span></span><br><span class="line">    <span class="keyword">let</span> semaphore <span class="operator">=</span> <span class="type">DispatchSemaphore</span>(value: <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">DispatchQueue</span>.global()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="number">10</span> &#123;</span><br><span class="line">        queue.async &#123;</span><br><span class="line">            <span class="comment">// 等待资源释放</span></span><br><span class="line">            semaphore.wait()</span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">            <span class="comment">// 任务结束，可以执行下一个等待任务</span></span><br><span class="line">            semaphore.signal()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">run()</span><br></pre></td></tr></table></figure> ## Operation Operation构建于GCD之上，提供了operation依赖、取消正在执行的operation等功能。每个operation有以下几种状态： - isReady：实例化完成，准备执行 - isExecuting：当调用start方法，operation进入该状态 - isCancelled：当调用cancel方法，operation进入该状态 - isFinished：如果operation正常结束，进入该状态</p>
<h3 id="两种创建方式">两种创建方式</h3>
<p><strong>1. BlockOperation</strong> 可以使用封装好的BlockOperation来新建operation。BlockOperation类似DispatchGroup，可以添加多个任务，每个任务会被并发执行。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sentence <span class="operator">=</span> <span class="string">&quot;Say hello to gcfeng&quot;</span></span><br><span class="line"><span class="keyword">let</span> wordOperation <span class="operator">=</span> <span class="type">BlockOperation</span>()</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> sentence.split(separator: <span class="string">&quot; &quot;</span>) &#123;</span><br><span class="line">    wordOperation.addExecutionBlock &#123;</span><br><span class="line">        <span class="built_in">print</span>(word)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当所有任务结束之后，执行</span></span><br><span class="line">wordOperation.completionBlock <span class="operator">=</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;All word printed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 启动</span></span><br><span class="line">wordOperation.start()</span><br></pre></td></tr></table></figure> <strong>2. 继承Operation</strong> 创建Operation子类对象，然后将对象添加到OperationQueue队列中，一旦对象被加入到队列中，队列就开始处理该对象，直到对象的所有操作都执行完成。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 创建Operation</span></span><br><span class="line">        <span class="keyword">let</span> downloadOperation <span class="operator">=</span> <span class="type">DownloadOperation</span>()</span><br><span class="line">        <span class="comment">// 创建队列</span></span><br><span class="line">        <span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">OperationQueue</span>()</span><br><span class="line">        queue.addOperation(downloadOperation)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadOperation</span>: <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;download&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Test</span>().run()</span><br></pre></td></tr></table></figure> ### 管理依赖 Operation的优势在于封装了Operation之间的依赖管理。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadOperation</span>: <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;download&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadOperation</span>: <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 检查依赖是否被取消或者自己被取消了</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="operator">!</span>dependencies.contains(<span class="keyword">where</span>: &#123; <span class="variable">$0</span>.isCancelled &#125;), <span class="operator">!</span>isCancelled <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;upload&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例化两个Operation</span></span><br><span class="line"><span class="keyword">let</span> downloadOperation <span class="operator">=</span> <span class="type">DownloadOperation</span>()</span><br><span class="line"><span class="keyword">let</span> uploadOperation <span class="operator">=</span> <span class="type">UploadOperation</span>()</span><br><span class="line"><span class="comment">// 定义uploadOperation依赖于downloadOperation</span></span><br><span class="line"><span class="comment">// 那么uploadOperation需要等待downloadOperation完成</span></span><br><span class="line">uploadOperation.addDependency(downloadOperation)</span><br><span class="line">uploadOperation.completionBlock <span class="operator">=</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;upload complete&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将Operation都添加到OperationQueue中</span></span><br><span class="line"><span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">OperationQueue</span>()</span><br><span class="line">queue.addOperations([downloadOperation, uploadOperation], waitUntilFinished: <span class="literal">false</span>)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
</search>
